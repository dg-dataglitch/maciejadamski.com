<!doctype html><html lang="en" class="dark h-full antialiased overflow-y-scroll"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- Basic Meta Tags --><title>Why you shouldn&#39;t use SELECT * in production - Maciej Adamski</title><meta name="description" content="A classic engineering trade-off: Convenience vs. Stability. Why SELECT * is a landmine in production applications, especially in Go."><meta name="robots" content="index, follow"><link rel="canonical" href="https://maciejadamski.com/blog/no-select-star/"><!-- Favicon --><link rel="icon" href="/static/favicon.ico" type="image/x-icon"><!-- Open Graph --><meta property="og:type" content="website"><meta property="og:url" content="https://maciejadamski.com/blog/no-select-star/"><meta property="og:title" content="Why you shouldn&#39;t use SELECT * in production - Maciej Adamski"><meta property="og:description" content="A classic engineering trade-off: Convenience vs. Stability. Why SELECT * is a landmine in production applications, especially in Go."><meta property="og:image" content="https://maciejadamski.com/static/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:image:alt" content="Maciej Adamski - Software Engineer"><meta property="og:site_name" content="Maciej Adamski"><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Why you shouldn&#39;t use SELECT * in production - Maciej Adamski"><meta name="twitter:description" content="A classic engineering trade-off: Convenience vs. Stability. Why SELECT * is a landmine in production applications, especially in Go."><meta name="twitter:image" content="https://maciejadamski.com/static/og-image.png"><meta name="twitter:site" content="@maciejadamski"><!-- Google Verification --><meta name="google-site-verification" content="Nax5qJbDjGM1csEKyBZpz9fu0fiEEsj_NhaR6VD5AYE"><!-- Structured Data (JSON-LD) --><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Maciej Adamski"},"datePublished":"2026-01-20","description":"A classic engineering trade-off: Convenience vs. Stability. Why SELECT * is a landmine in production applications, especially in Go.","headline":"Why you shouldn't use SELECT * in production - Maciej Adamski","image":"https://maciejadamski.com/static/og-image.png","mainEntityOfPage":{"@id":"https://maciejadamski.com/blog/no-select-star/","@type":"WebPage"},"publisher":{"@type":"Organization","name":"Maciej Adamski"},"url":"https://maciejadamski.com/blog/no-select-star/"}</script><!-- Fonts: Dynamic based on config + JetBrains Mono for code --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Google+Sans+Flex:opsz,wght@6..144,1..1000&amp;family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100..800&display=swap" rel="stylesheet"><!-- Custom CSS --><link rel="stylesheet" href="/static/css/prose.css"><!-- Tailwind CSS --><script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script><script src="https://cdn.jsdelivr.net/npm/@tailwindplus/elements@1" type="module"></script><!-- Theme Config -->
		<style>
		:root {
			--font-sans: 'Google Sans Flex', 'Inter', sans-serif;
			--font-mono: 'JetBrains Mono', monospace;
			--color-text-heading: #121317;
			--color-text-body: #5f6368;
			--color-text-muted: #70757a;
			--color-text-bold: #121317;
			--color-text-italic: #3c4043;
			--color-text-code: #52008d;
			--color-text-pre: #e8eaed;
			--color-link: #0b57d0;
			--color-brand: #52008d;
			--color-surface: #f8f9fc;
			--color-page-background: #ffffff;
			--color-border: #dadce0;
			--color-border-dark: #c4c7cc;
			--color-scrollbar: #a8a29e;
			--color-code-background: #212226;
			--radius-container: 8px;
		}
		</style>
	<style type="text/tailwindcss">
				@theme {
						--font-sans: var(--font-sans);
						--font-mono: var(--font-mono);
						--color-heading: var(--color-text-heading);
						--color-body: var(--color-text-body);
						--color-bold: var(--color-text-bold);
						--color-italic: var(--color-text-italic);
						--color-code: var(--color-text-code);
						--color-pre: var(--color-text-pre);
						--color-link: var(--color-link);
						--color-brand: var(--color-brand);
						--color-surface: var(--color-surface);
						--color-page-background: var(--color-page-background);
						--color-border: var(--color-border);
				}
			</style><!-- Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-8N2WJRPVCH"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-8N2WJRPVCH');</script></head><body class="min-h-full flex flex-col antialiased bg-page-background text-text-body"><header class="fixed inset-x-0 top-0 z-50 bg-white border-b border-border"><nav aria-label="Global" class="mx-auto max-w-7xl flex items-center justify-between px-4 py-3 lg:px-8"><a href="/" class="flex-1 lg:flex-initial"><span class="text-2xl text-heading font-bold tracking-tight">ma_</span></a><!-- Mobile menu button --><button type="button" command="show-modal" commandfor="mobile-menu" class="lg:hidden inline-flex items-center justify-center rounded-full bg-heading text-white px-4 py-2"><span class="sr-only">Open menu</span> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="size-5"><path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round"></path></svg></button><!-- Desktop navigation --><div class="hidden lg:flex lg:gap-x-8"><a href="/blog/" class="text-sm font-medium text-body">/blog</a> <a href="/blog/ai-coding-partner-instructions-go/" class="text-sm font-medium text-body">/ai-rules</a> <a href="/#contact" class="text-sm font-medium text-body">/contact</a></div></nav></header><!-- Mobile menu --><el-dialog><dialog id="mobile-menu" class="fixed inset-0 m-0 w-full h-full max-w-none max-h-none border-0 bg-white p-0 lg:hidden"><div class="h-full overflow-y-auto"><div class="flex items-center justify-between px-4 py-3 border-b border-border"><a href="/"><span class="text-2xl text-heading font-bold tracking-tight">ma_</span></a> <button type="button" command="close" commandfor="mobile-menu" class="inline-flex items-center justify-center rounded-full bg-heading text-white px-4 py-2"><span class="sr-only">Close menu</span> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="size-5"><path d="M6 18L18 6M6 6l12 12" stroke-linecap="round" stroke-linejoin="round"></path></svg></button></div><nav class="px-4 py-6"><a href="/blog/" class="block py-6 text-2xl font-medium text-heading border-b border-border">/blog</a> <a href="/blog/ai-coding-partner-instructions-go/" class="block py-6 text-2xl font-medium text-heading border-b border-border">/ai-rules</a> <a href="/#contact" class="block py-6 text-2xl font-medium text-heading border-b border-border">/contact</a></nav></div></dialog></el-dialog><main class="flex-1"><article class="max-w-3xl mx-auto py-24 px-4 lg:px-8"><header class="mb-12"><h1 class="text-4xl text-heading font-semibold tracking-tight leading-tight mb-4">Why you shouldn&#39;t use SELECT * in production</h1><div class="flex gap-2 text-body text-sm"><span>January 20, 2026</span> <span>•</span> <span>by Maciej Adamski</span></div></header><div class="prose prose-invert max-w-none"><p><strong>TL;DR:</strong> Using <code>SELECT *</code> in production is a high-interest loan on your future stability. In Go, it leads to silent crashes during schema changes, destroys database performance by bypassing indexes, and creates &quot;dark code&quot; that is impossible to refactor. Use explicit column lists and low-abstraction drivers like <code>pgx</code> to keep your system predictable.</p>
<hr>
<p>In a quick prototype or a local script, <code>SELECT *</code> feels like a shortcut. It's easy and fast. But in a production Go application, that shortcut is a landmine waiting for a teammate to step on it.</p>
<p>Software engineering is the art of making trade-offs. While <code>SELECT *</code> offers <strong>convenience</strong>, it sacrifices <strong>stability</strong>. Here is why high-level engineering requires explicit column selection.</p>
<h2>What is the &quot;positional scan&quot; crash?</h2>
<p>In Go, the standard <code>database/sql</code> package—and even lower-level drivers—are remarkably literal. When you use <code>row.Scan()</code>, the program doesn't look at column names; it only sees the <strong>order</strong> of the data coming off the wire.</p>
<ul>
<li><strong>The implicit contract:</strong> Your code expects Column 1 to be an <code>ID</code> (int) and Column 2 to be an <code>Email</code> (string).</li>
<li><strong>The fragile reality:</strong> If a teammate runs a migration—perhaps adding a <code>MiddleName</code> column between <code>ID</code> and <code>Email</code>—your code will blindly try to shove a string into an integer variable.</li>
</ul>
<p><strong>The result:</strong> Your application crashes in production with a type mismatch error. By explicitly listing your columns, you guarantee the order of the data, making your logic immune to schema changes.</p>
<h2>How does SELECT * kill database performance?</h2>
<p>Engineering isn't just about how fast a query runs on the database; it's about the entire data pipeline.</p>
<h3>Network and memory bloat</h3>
<p>Your <code>users</code> table might be lean today. But what happens when someone adds a <code>profile_picture_blob</code> or a massive <code>metadata</code> JSON field? If you use <code>SELECT *</code>, you are now dragging megabytes of unnecessary data across the network and deserializing it into memory for every single query—even if you only needed a username.</p>
<h3>The &quot;covering index&quot; hit</h3>
<p>This is the Staff-level &quot;why.&quot; Databases are fast because of <strong>indexes</strong>. A &quot;Covering Index&quot; allows the database to answer your query using only the index, without ever touching the actual table (the &quot;heap&quot;).</p>
<p>When you use <code>SELECT *</code>, you force the database to fetch every single column from the heap. You effectively kill the database's ability to stay in its &quot;fast lane,&quot; turning a millisecond operation into a disk-I/O bottleneck.</p>
<h2>Why does greppability matter for refactoring?</h2>
<p>Code must be searchable. Imagine you are tasked with renaming a column or deprecating a field.</p>
<p>If you explicitly list <code>email_address</code> in your SQL queries, a simple <code>grep</code> or &quot;Find Usages&quot; in your IDE will show you exactly which parts of your Go application are affected. If you use <code>SELECT *</code>, your code becomes a <strong>black box</strong>. You have no way of knowing which fields are actually used by the business logic without running the code and hoping for the best.</p>
<p><strong>Explicit code is maintainable code.</strong></p>
<h2>Why should you use pgx over &quot;magic&quot; frameworks?</h2>
<p>Choosing a tool like <strong><code>pgx</code></strong> over a heavy ORM follows the philosophy of <strong>&quot;Simple, not easy.&quot;</strong></p>
<ul>
<li><strong>Performance:</strong> <code>pgx</code> supports PostgreSQL-specific features like binary protocol and <code>COPY</code> that generic wrappers hide.</li>
<li><strong>Transparency:</strong> The SQL you write is the SQL that runs. There are no &quot;hidden&quot; queries generated by a library behind your back.</li>
<li><strong>Granular control:</strong> It gives you PostgreSQL-specific error codes, making it easy to distinguish a connection timeout from a constraint violation.</li>
</ul>
<h2>What does the code look like: Before and after?</h2>
<h3>❌ The &quot;landmine&quot; (fragile)</h3>
<pre><code class="language-go">func GetUser(ctx context.Context, db *pgx.Conn, id int) (*User, error) {
    var u User
    // DANGER: If the DB schema changes order, this will fail or corrupt data.
    err := db.QueryRow(ctx, &quot;SELECT * FROM users WHERE id=$1&quot;, id).Scan(
        &amp;u.ID, 
        &amp;u.Email, 
        &amp;u.Name,
    )
    return &amp;u, err
}
</code></pre>
<h3>✅ The &quot;contract&quot; (robust)</h3>
<pre><code class="language-go">const userFields = &quot;id, email, name&quot;

func GetUser(ctx context.Context, db *pgx.Conn, id int) (*User, error) {
    var u User
    query := fmt.Sprintf(&quot;SELECT %s FROM users WHERE id=$1&quot;, userFields)
    
    // Explicit list: even if the table grows to 100 columns, this remains fast.
    err := db.QueryRow(ctx, query, id).Scan(
        &amp;u.ID, 
        &amp;u.Email, 
        &amp;u.Name,
    )
    
    if err != nil {
        return nil, fmt.Errorf(&quot;fetch user: %w&quot;, err)
    }
    return &amp;u, nil
}
</code></pre>
<h2>Frequently Asked Questions</h2>
<p><strong>Is SELECT * ever acceptable?</strong></p>
<p>In ad-hoc queries, local scripts, or database exploration tools—yes. In production application code—never. The trade-off always favors stability over convenience.</p>
<p><strong>What if my table has 50 columns and I need most of them?</strong></p>
<p>Define a constant like <code>const userFields = &quot;col1, col2, col3, ...&quot;</code> at the top of your repository file. This keeps queries readable and gives you a single source of truth for which columns you depend on.</p>
<p><strong>Does this advice apply to ORMs like GORM?</strong></p>
<p>Yes. Even ORMs that handle column mapping can suffer from performance issues (fetching unnecessary columns) and make refactoring harder. Prefer explicit <code>Select()</code> clauses over default behavior.</p>
<p><strong>How do I catch SELECT * in code reviews?</strong></p>
<p>Add a linter rule or grep check to your CI pipeline that flags any occurrence of <code>SELECT *</code> or <code>select *</code> in your codebase.</p>
<h2>Summary</h2>
<p>A junior engineer writes code that works today. A Senior engineer writes code that works three years from now, even after dozens of schema migrations.</p>
<p>Avoid SELECT *. Be explicit. Treat your SQL as a strict contract, and your production environment will thank you.</p>
<h3>About the Author</h3>
<p>Maciej Adamski is a software engineer and founder of Dataglitch, specializing in Go backend development and PostgreSQL optimization. He writes about database best practices, software craftsmanship, and the pursuit of simplicity in code.</p>
</div><footer class="mt-16 pt-8 border-t border-border"><a href="/blog/" class="text-sm font-semibold text-link underline underline-offset-4"><span aria-hidden="true">&larr;</span> Back to blog</a></footer></article></main><footer class="border-t border-border"><div class="mx-auto max-w-7xl px-6 py-16 flex items-center justify-center lg:px-8"><p class="text-center text-sm text-body">&copy; 2026 Maciej Adamski. All rights reserved.</p></div></footer></body></html>